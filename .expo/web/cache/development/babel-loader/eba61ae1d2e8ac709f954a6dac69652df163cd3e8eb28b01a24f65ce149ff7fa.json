{"ast":null,"code":"'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nimport UTFSequence from \"../../UTFSequence\";\nimport stringifySafe from \"../../Utilities/stringifySafe\";\nvar BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nvar BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*):? (?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?)(\\/(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+?)\\n([ >]{2}[\\t-\\r 0-9\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+ \\|(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|\\x1B(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/;\nvar METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*) \\(([0-9]+):([0-9]+)\\)\\n\\n((?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/;\nvar SUBSTITUTION = UTFSequence.BOM + '%s';\nexport function parseInterpolation(args) {\n  var categoryParts = [];\n  var contentParts = [];\n  var substitutionOffsets = [];\n  var remaining = _toConsumableArray(args);\n  if (typeof remaining[0] === 'string') {\n    var formatString = String(remaining.shift());\n    var formatStringParts = formatString.split('%s');\n    var substitutionCount = formatStringParts.length - 1;\n    var substitutions = remaining.splice(0, substitutionCount);\n    var categoryString = '';\n    var contentString = '';\n    var substitutionIndex = 0;\n    for (var _iterator = _createForOfIteratorHelperLoose(formatStringParts), _step; !(_step = _iterator()).done;) {\n      var formatStringPart = _step.value;\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          var substitution = typeof substitutions[substitutionIndex] === 'string' ? substitutions[substitutionIndex] : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length\n          });\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length\n          });\n          categoryString += '%s';\n          contentString += '%s';\n        }\n        substitutionIndex++;\n      }\n    }\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n  var remainingArgs = remaining.map(function (arg) {\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\n  });\n  categoryParts.push.apply(categoryParts, _toConsumableArray(remainingArgs));\n  contentParts.push.apply(contentParts, _toConsumableArray(remainingArgs));\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets\n    }\n  };\n}\nexport function parseComponentStack(message) {\n  return message.split(/\\n {4}in /g).map(function (s) {\n    if (!s) {\n      return null;\n    }\n    var match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n    if (!match) {\n      return null;\n    }\n    var _match$slice = match.slice(1),\n      _match$slice2 = _slicedToArray(_match$slice, 3),\n      content = _match$slice2[0],\n      fileName = _match$slice2[1],\n      row = _match$slice2[2];\n    return {\n      content: content,\n      fileName: fileName,\n      location: {\n        column: -1,\n        row: parseInt(row, 10)\n      }\n    };\n  }).filter(Boolean);\n}\nexport function parseLogBoxException(error) {\n  var message = error.originalMessage != null ? error.originalMessage : 'Unknown';\n  var metroInternalError = message.match(METRO_ERROR_FORMAT);\n  if (metroInternalError) {\n    var _metroInternalError$s = metroInternalError.slice(1),\n      _metroInternalError$s2 = _slicedToArray(_metroInternalError$s, 5),\n      content = _metroInternalError$s2[0],\n      fileName = _metroInternalError$s2[1],\n      row = _metroInternalError$s2[2],\n      column = _metroInternalError$s2[3],\n      codeFrame = _metroInternalError$s2[4];\n    return {\n      level: 'fatal',\n      type: 'Metro Error',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10)\n        },\n        content: codeFrame\n      },\n      message: {\n        content: content,\n        substitutions: []\n      },\n      category: fileName + \"-\" + row + \"-\" + column\n    };\n  }\n  var babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    var _babelTransformError$ = babelTransformError.slice(1),\n      _babelTransformError$2 = _slicedToArray(_babelTransformError$, 5),\n      _fileName = _babelTransformError$2[0],\n      _content = _babelTransformError$2[1],\n      _row = _babelTransformError$2[2],\n      _column = _babelTransformError$2[3],\n      _codeFrame = _babelTransformError$2[4];\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: _fileName,\n        location: {\n          row: parseInt(_row, 10),\n          column: parseInt(_column, 10)\n        },\n        content: _codeFrame\n      },\n      message: {\n        content: _content,\n        substitutions: []\n      },\n      category: _fileName + \"-\" + _row + \"-\" + _column\n    };\n  }\n  var babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n  if (babelCodeFrameError) {\n    var _babelCodeFrameError$ = babelCodeFrameError.slice(1),\n      _babelCodeFrameError$2 = _slicedToArray(_babelCodeFrameError$, 3),\n      _fileName2 = _babelCodeFrameError$2[0],\n      _content2 = _babelCodeFrameError$2[1],\n      _codeFrame2 = _babelCodeFrameError$2[2];\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: _fileName2,\n        location: null,\n        content: _codeFrame2\n      },\n      message: {\n        content: _content2,\n        substitutions: []\n      },\n      category: _fileName2 + \"-\" + 1 + \"-\" + 1\n    };\n  }\n  if (message.match(/^TransformError /)) {\n    return {\n      level: 'syntax',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: []\n      },\n      category: message\n    };\n  }\n  var componentStack = error.componentStack;\n  if (error.isFatal || error.isComponentError) {\n    return _objectSpread({\n      level: 'fatal',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: componentStack != null ? parseComponentStack(componentStack) : []\n    }, parseInterpolation([message]));\n  }\n  if (componentStack != null) {\n    return _objectSpread({\n      level: 'error',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: parseComponentStack(componentStack)\n    }, parseInterpolation([message]));\n  }\n  return _objectSpread({\n    level: 'error',\n    stack: error.stack,\n    isComponentError: error.isComponentError\n  }, parseLogBoxLog([message]));\n}\nexport function parseLogBoxLog(args) {\n  var message = args[0];\n  var argsWithoutComponentStack = [];\n  var componentStack = [];\n  if (typeof message === 'string' && message.slice(-2) === '%s' && args.length > 0) {\n    var lastArg = args[args.length - 1];\n    if (typeof lastArg === 'string' && /\\s{4}in/.test(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n  if (componentStack.length === 0) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(args), _step2; !(_step2 = _iterator2()).done;) {\n      var arg = _step2.value;\n      if (typeof arg === 'string' && /\\n {4}in /.exec(arg)) {\n        var messageEndIndex = arg.indexOf('\\n    in ');\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n  return _objectSpread(_objectSpread({}, parseInterpolation(argsWithoutComponentStack)), {}, {\n    componentStack: componentStack\n  });\n}","map":{"version":3,"names":["_defineProperty","_slicedToArray","_toConsumableArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","call","next","bind","Array","isArray","_unsupportedIterableToArray","done","value","TypeError","minLen","_arrayLikeToArray","n","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","UTFSequence","stringifySafe","BABEL_TRANSFORM_ERROR_FORMAT","BABEL_CODE_FRAME_ERROR_FORMAT","METRO_ERROR_FORMAT","SUBSTITUTION","BOM","parseInterpolation","args","categoryParts","contentParts","substitutionOffsets","remaining","formatString","String","shift","formatStringParts","split","substitutionCount","substitutions","splice","categoryString","contentString","substitutionIndex","_iterator","_step","formatStringPart","substitution","offset","remainingArgs","map","arg","category","join","message","content","parseComponentStack","s","match","_match$slice","_match$slice2","fileName","row","location","column","parseInt","Boolean","parseLogBoxException","error","originalMessage","metroInternalError","_metroInternalError$s","_metroInternalError$s2","codeFrame","level","type","stack","isComponentError","componentStack","babelTransformError","_babelTransformError$","_babelTransformError$2","babelCodeFrameError","_babelCodeFrameError$","_babelCodeFrameError$2","isFatal","parseLogBoxLog","argsWithoutComponentStack","lastArg","_iterator2","_step2","exec","messageEndIndex","indexOf"],"sources":["D:/React-Native/Pharma/node_modules/react-native/Libraries/LogBox/Data/parseLogBoxLog.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport UTFSequence from '../../UTFSequence';\nimport stringifySafe from '../../Utilities/stringifySafe';\nimport type {ExceptionData} from '../../Core/NativeExceptionsManager';\nimport type {LogBoxLogData} from './LogBoxLog';\n\nconst BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nconst BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:.*):? (?:.*?)(\\/.*): ([\\s\\S]+?)\\n([ >]{2}[\\d\\s]+ \\|[\\s\\S]+|\\u{001b}[\\s\\S]+)/u;\nconst METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) (.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/u;\n\nexport type ExtendedExceptionData = ExceptionData & {\n  isComponentError: boolean,\n  ...\n};\nexport type Category = string;\nexport type CodeFrame = $ReadOnly<{|\n  content: string,\n  location: ?{\n    row: number,\n    column: number,\n    ...\n  },\n  fileName: string,\n|}>;\nexport type Message = $ReadOnly<{|\n  content: string,\n  substitutions: $ReadOnlyArray<\n    $ReadOnly<{|\n      length: number,\n      offset: number,\n    |}>,\n  >,\n|}>;\n\nexport type ComponentStack = $ReadOnlyArray<CodeFrame>;\n\nconst SUBSTITUTION = UTFSequence.BOM + '%s';\n\nexport function parseInterpolation(\n  args: $ReadOnlyArray<mixed>,\n): $ReadOnly<{|\n  category: Category,\n  message: Message,\n|}> {\n  const categoryParts = [];\n  const contentParts = [];\n  const substitutionOffsets = [];\n\n  const remaining = [...args];\n  if (typeof remaining[0] === 'string') {\n    const formatString = String(remaining.shift());\n    const formatStringParts = formatString.split('%s');\n    const substitutionCount = formatStringParts.length - 1;\n    const substitutions = remaining.splice(0, substitutionCount);\n\n    let categoryString = '';\n    let contentString = '';\n\n    let substitutionIndex = 0;\n    for (const formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          // Don't stringify a string type.\n          // It adds quotation mark wrappers around the string,\n          // which causes the LogBox to look odd.\n          const substitution =\n            typeof substitutions[substitutionIndex] === 'string'\n              ? substitutions[substitutionIndex]\n              : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length,\n          });\n\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length,\n          });\n\n          categoryString += '%s';\n          contentString += '%s';\n        }\n\n        substitutionIndex++;\n      }\n    }\n\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n\n  const remainingArgs = remaining.map(arg => {\n    // Don't stringify a string type.\n    // It adds quotation mark wrappers around the string,\n    // which causes the LogBox to look odd.\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\n  });\n  categoryParts.push(...remainingArgs);\n  contentParts.push(...remainingArgs);\n\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets,\n    },\n  };\n}\n\nexport function parseComponentStack(message: string): ComponentStack {\n  return message\n    .split(/\\n {4}in /g)\n    .map(s => {\n      if (!s) {\n        return null;\n      }\n      const match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n      if (!match) {\n        return null;\n      }\n\n      let [content, fileName, row] = match.slice(1);\n      return {\n        content,\n        fileName,\n        location: {column: -1, row: parseInt(row, 10)},\n      };\n    })\n    .filter(Boolean);\n}\n\nexport function parseLogBoxException(\n  error: ExtendedExceptionData,\n): LogBoxLogData {\n  const message =\n    error.originalMessage != null ? error.originalMessage : 'Unknown';\n\n  const metroInternalError = message.match(METRO_ERROR_FORMAT);\n  if (metroInternalError) {\n    const [\n      content,\n      fileName,\n      row,\n      column,\n      codeFrame,\n    ] = metroInternalError.slice(1);\n\n    return {\n      level: 'fatal',\n      type: 'Metro Error',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n    };\n  }\n\n  const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    // Transform errors are thrown from inside the Babel transformer.\n    const [\n      fileName,\n      content,\n      row,\n      column,\n      codeFrame,\n    ] = babelTransformError.slice(1);\n\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n    };\n  }\n\n  const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n\n  if (babelCodeFrameError) {\n    // Codeframe errors are thrown from any use of buildCodeFrameError.\n    const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: null, // We are not given the location.\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${1}-${1}`,\n    };\n  }\n\n  if (message.match(/^TransformError /)) {\n    return {\n      level: 'syntax',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: [],\n      },\n      category: message,\n    };\n  }\n\n  const componentStack = error.componentStack;\n  if (error.isFatal || error.isComponentError) {\n    return {\n      level: 'fatal',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack:\n        componentStack != null ? parseComponentStack(componentStack) : [],\n      ...parseInterpolation([message]),\n    };\n  }\n\n  if (componentStack != null) {\n    // It is possible that console errors have a componentStack.\n    return {\n      level: 'error',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: parseComponentStack(componentStack),\n      ...parseInterpolation([message]),\n    };\n  }\n\n  // Most `console.error` calls won't have a componentStack. We parse them like\n  // regular logs which have the component stack burried in the message.\n  return {\n    level: 'error',\n    stack: error.stack,\n    isComponentError: error.isComponentError,\n    ...parseLogBoxLog([message]),\n  };\n}\n\nexport function parseLogBoxLog(\n  args: $ReadOnlyArray<mixed>,\n): {|\n  componentStack: ComponentStack,\n  category: Category,\n  message: Message,\n|} {\n  const message = args[0];\n  let argsWithoutComponentStack = [];\n  let componentStack = [];\n\n  // Extract component stack from warnings like \"Some warning%s\".\n  if (\n    typeof message === 'string' &&\n    message.slice(-2) === '%s' &&\n    args.length > 0\n  ) {\n    const lastArg = args[args.length - 1];\n    // Does it look like React component stack? \"   in ...\"\n    if (typeof lastArg === 'string' && /\\s{4}in/.test(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n\n  if (componentStack.length === 0) {\n    // Try finding the component stack elsewhere.\n    for (const arg of args) {\n      if (typeof arg === 'string' && /\\n {4}in /.exec(arg)) {\n        // Strip out any messages before the component stack.\n        const messageEndIndex = arg.indexOf('\\n    in ');\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n\n  return {\n    ...parseInterpolation(argsWithoutComponentStack),\n    componentStack,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}