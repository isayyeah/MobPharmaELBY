{"ast":null,"code":"'use strict';\n\nvar BatchedBridge = require(\"../../BatchedBridge/BatchedBridge\");\nvar Platform = require(\"../../Utilities/Platform\");\nvar Systrace = require(\"../../Performance/Systrace\");\nvar invariant = require('invariant');\nimport NativeTiming from \"./NativeTiming\";\nvar _performanceNow = null;\nfunction performanceNow() {\n  if (!_performanceNow) {\n    _performanceNow = require('fbjs/lib/performanceNow');\n  }\n  return _performanceNow();\n}\nvar FRAME_DURATION = 1000 / 60;\nvar IDLE_CALLBACK_FRAME_DEADLINE = 1;\nvar MAX_TIMER_DURATION_MS = 60 * 1000;\nvar IS_ANDROID = Platform.OS === 'android';\nvar ANDROID_LONG_TIMER_MESSAGE = 'Setting a timer for a long period of time, i.e. multiple minutes, is a ' + 'performance and correctness issue on Android as it keeps the timer ' + 'module awake, and timers can only be called when the app is in the foreground. ' + 'See https://github.com/facebook/react-native/issues/12981 for more info.';\nvar callbacks = [];\nvar types = [];\nvar timerIDs = [];\nvar immediates = [];\nvar requestIdleCallbacks = [];\nvar requestIdleCallbackTimeouts = {};\nvar GUID = 1;\nvar errors = null;\nvar hasEmittedTimeDriftWarning = false;\nfunction _getFreeIndex() {\n  var freeIndex = timerIDs.indexOf(null);\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n  return freeIndex;\n}\nfunction _allocateCallback(func, type) {\n  var id = GUID++;\n  var freeIndex = _getFreeIndex();\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n  return id;\n}\nfunction _callTimer(timerID, frameTime, didTimeout) {\n  require('fbjs/lib/warning')(timerID <= GUID, 'Tried to call timer with ID %s but no such timer exists.', timerID);\n  var timerIndex = timerIDs.indexOf(timerID);\n  if (timerIndex === -1) {\n    return;\n  }\n  var type = types[timerIndex];\n  var callback = callbacks[timerIndex];\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n  if (__DEV__) {\n    Systrace.beginEvent(type + ' [invoke]');\n  }\n  if (type !== 'setInterval') {\n    _clearIndex(timerIndex);\n  }\n  try {\n    if (type === 'setTimeout' || type === 'setInterval' || type === 'setImmediate') {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(performanceNow());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function timeRemaining() {\n          return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));\n        },\n        didTimeout: !!didTimeout\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    if (!errors) {\n      errors = [e];\n    } else {\n      errors.push(e);\n    }\n  }\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\nfunction _callImmediatesPass() {\n  if (immediates.length === 0) {\n    return false;\n  }\n  if (__DEV__) {\n    Systrace.beginEvent('callImmediatesPass()');\n  }\n  var passImmediates = immediates;\n  immediates = [];\n  for (var i = 0; i < passImmediates.length; ++i) {\n    _callTimer(passImmediates[i], 0);\n  }\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n  return immediates.length > 0;\n}\nfunction _clearIndex(i) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n}\nfunction _freeCallback(timerID) {\n  if (timerID == null) {\n    return;\n  }\n  var index = timerIDs.indexOf(timerID);\n  if (index !== -1) {\n    var type = types[index];\n    _clearIndex(index);\n    if (type !== 'setImmediate' && type !== 'requestIdleCallback') {\n      deleteTimer(timerID);\n    }\n  }\n}\nvar JSTimers = {\n  setTimeout: function setTimeout(func, duration) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(ANDROID_LONG_TIMER_MESSAGE + '\\n' + '(Saw setTimeout with duration ' + duration + 'ms)');\n    }\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setTimeout');\n    createTimer(id, duration || 0, Date.now(), false);\n    return id;\n  },\n  setInterval: function setInterval(func, duration) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(ANDROID_LONG_TIMER_MESSAGE + '\\n' + '(Saw setInterval with duration ' + duration + 'ms)');\n    }\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setInterval');\n    createTimer(id, duration || 0, Date.now(), true);\n    return id;\n  },\n  setImmediate: function setImmediate(func) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setImmediate');\n    immediates.push(id);\n    return id;\n  },\n  requestAnimationFrame: function requestAnimationFrame(func) {\n    var id = _allocateCallback(func, 'requestAnimationFrame');\n    createTimer(id, 1, Date.now(), false);\n    return id;\n  },\n  requestIdleCallback: function requestIdleCallback(func, options) {\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(true);\n    }\n    var timeout = options && options.timeout;\n    var id = _allocateCallback(timeout != null ? function (deadline) {\n      var timeoutId = requestIdleCallbackTimeouts[id];\n      if (timeoutId) {\n        JSTimers.clearTimeout(timeoutId);\n        delete requestIdleCallbackTimeouts[id];\n      }\n      return func(deadline);\n    } : func, 'requestIdleCallback');\n    requestIdleCallbacks.push(id);\n    if (timeout != null) {\n      var timeoutId = JSTimers.setTimeout(function () {\n        var index = requestIdleCallbacks.indexOf(id);\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n          _callTimer(id, performanceNow(), true);\n        }\n        delete requestIdleCallbackTimeouts[id];\n        if (requestIdleCallbacks.length === 0) {\n          setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n    return id;\n  },\n  cancelIdleCallback: function cancelIdleCallback(timerID) {\n    _freeCallback(timerID);\n    var index = requestIdleCallbacks.indexOf(timerID);\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n    var timeoutId = requestIdleCallbackTimeouts[timerID];\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n  },\n  clearTimeout: function clearTimeout(timerID) {\n    _freeCallback(timerID);\n  },\n  clearInterval: function clearInterval(timerID) {\n    _freeCallback(timerID);\n  },\n  clearImmediate: function clearImmediate(timerID) {\n    _freeCallback(timerID);\n    var index = immediates.indexOf(timerID);\n    if (index !== -1) {\n      immediates.splice(index, 1);\n    }\n  },\n  cancelAnimationFrame: function cancelAnimationFrame(timerID) {\n    _freeCallback(timerID);\n  },\n  callTimers: function callTimers(timersToCall) {\n    invariant(timersToCall.length !== 0, 'Cannot call `callTimers` with an empty list of IDs.');\n    errors = null;\n    for (var i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n    if (errors) {\n      var errorCount = errors.length;\n      if (errorCount > 1) {\n        for (var ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(function (error) {\n            throw error;\n          }.bind(null, errors[ii]), 0);\n        }\n      }\n      throw errors[0];\n    }\n  },\n  callIdleCallbacks: function callIdleCallbacks(frameTime) {\n    if (FRAME_DURATION - (performanceNow() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {\n      return;\n    }\n    errors = null;\n    if (requestIdleCallbacks.length > 0) {\n      var passIdleCallbacks = requestIdleCallbacks;\n      requestIdleCallbacks = [];\n      for (var i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n    if (errors) {\n      errors.forEach(function (error) {\n        return JSTimers.setTimeout(function () {\n          throw error;\n        }, 0);\n      });\n    }\n  },\n  callImmediates: function callImmediates() {\n    errors = null;\n    while (_callImmediatesPass()) {}\n    if (errors) {\n      errors.forEach(function (error) {\n        return JSTimers.setTimeout(function () {\n          throw error;\n        }, 0);\n      });\n    }\n  },\n  emitTimeDriftWarning: function emitTimeDriftWarning(warningMessage) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  }\n};\nfunction createTimer(callbackID, duration, jsSchedulingTime, repeats) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.createTimer(callbackID, duration, jsSchedulingTime, repeats);\n}\nfunction deleteTimer(timerID) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.deleteTimer(timerID);\n}\nfunction setSendIdleEvents(sendIdleEvents) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.setSendIdleEvents(sendIdleEvents);\n}\nvar ExportedJSTimers;\nif (!NativeTiming) {\n  console.warn(\"Timing native module is not available, can't set timers.\");\n  ExportedJSTimers = {\n    callImmediates: JSTimers.callImmediates,\n    setImmediate: JSTimers.setImmediate\n  };\n} else {\n  ExportedJSTimers = JSTimers;\n}\nBatchedBridge.setImmediatesCallback(JSTimers.callImmediates);\nmodule.exports = ExportedJSTimers;","map":{"version":3,"names":["BatchedBridge","require","Platform","Systrace","invariant","NativeTiming","_performanceNow","performanceNow","FRAME_DURATION","IDLE_CALLBACK_FRAME_DEADLINE","MAX_TIMER_DURATION_MS","IS_ANDROID","OS","ANDROID_LONG_TIMER_MESSAGE","callbacks","types","timerIDs","immediates","requestIdleCallbacks","requestIdleCallbackTimeouts","GUID","errors","hasEmittedTimeDriftWarning","_getFreeIndex","freeIndex","indexOf","length","_allocateCallback","func","type","id","_callTimer","timerID","frameTime","didTimeout","timerIndex","callback","console","error","__DEV__","beginEvent","_clearIndex","timeRemaining","Math","max","e","push","endEvent","_callImmediatesPass","passImmediates","i","_freeCallback","index","deleteTimer","JSTimers","setTimeout","duration","_len","arguments","args","Array","_key","warn","apply","undefined","createTimer","Date","now","setInterval","_len2","_key2","setImmediate","_len3","_key3","requestAnimationFrame","requestIdleCallback","options","setSendIdleEvents","timeout","deadline","timeoutId","clearTimeout","splice","cancelIdleCallback","clearInterval","clearImmediate","cancelAnimationFrame","callTimers","timersToCall","errorCount","ii","bind","callIdleCallbacks","passIdleCallbacks","forEach","callImmediates","emitTimeDriftWarning","warningMessage","callbackID","jsSchedulingTime","repeats","sendIdleEvents","ExportedJSTimers","setImmediatesCallback","module","exports"],"sources":["D:/React-Native/Pharma/node_modules/react-native/Libraries/Core/Timers/JSTimers.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst BatchedBridge = require('../../BatchedBridge/BatchedBridge');\nconst Platform = require('../../Utilities/Platform');\nconst Systrace = require('../../Performance/Systrace');\n\nconst invariant = require('invariant');\n\nimport NativeTiming from './NativeTiming';\n\nlet _performanceNow = null;\nfunction performanceNow() {\n  if (!_performanceNow) {\n    _performanceNow = require('fbjs/lib/performanceNow');\n  }\n  return _performanceNow();\n}\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\n\nexport type JSTimerType =\n  | 'setTimeout'\n  | 'setInterval'\n  | 'requestAnimationFrame'\n  | 'setImmediate'\n  | 'requestIdleCallback';\n\n// These timing constants should be kept in sync with the ones in native ios and\n// android `RCTTiming` module.\nconst FRAME_DURATION = 1000 / 60;\nconst IDLE_CALLBACK_FRAME_DEADLINE = 1;\n\nconst MAX_TIMER_DURATION_MS = 60 * 1000;\nconst IS_ANDROID = Platform.OS === 'android';\nconst ANDROID_LONG_TIMER_MESSAGE =\n  'Setting a timer for a long period of time, i.e. multiple minutes, is a ' +\n  'performance and correctness issue on Android as it keeps the timer ' +\n  'module awake, and timers can only be called when the app is in the foreground. ' +\n  'See https://github.com/facebook/react-native/issues/12981 for more info.';\n\n// Parallel arrays\nconst callbacks: Array<?Function> = [];\nconst types: Array<?JSTimerType> = [];\nconst timerIDs: Array<?number> = [];\nlet immediates: Array<number> = [];\nlet requestIdleCallbacks: Array<number> = [];\nconst requestIdleCallbackTimeouts: {[number]: number, ...} = {};\n\nlet GUID = 1;\nlet errors: ?Array<Error> = null;\n\nlet hasEmittedTimeDriftWarning = false;\n\n// Returns a free index if one is available, and the next consecutive index otherwise.\nfunction _getFreeIndex(): number {\n  let freeIndex = timerIDs.indexOf(null);\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n  return freeIndex;\n}\n\nfunction _allocateCallback(func: Function, type: JSTimerType): number {\n  const id = GUID++;\n  const freeIndex = _getFreeIndex();\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n  return id;\n}\n\n/**\n * Calls the callback associated with the ID. Also unregister that callback\n * if it was a one time timer (setTimeout), and not unregister it if it was\n * recurring (setInterval).\n */\nfunction _callTimer(timerID: number, frameTime: number, didTimeout: ?boolean) {\n  require('fbjs/lib/warning')(\n    timerID <= GUID,\n    'Tried to call timer with ID %s but no such timer exists.',\n    timerID,\n  );\n\n  // timerIndex of -1 means that no timer with that ID exists. There are\n  // two situations when this happens, when a garbage timer ID was given\n  // and when a previously existing timer was deleted before this callback\n  // fired. In both cases we want to ignore the timer id, but in the former\n  // case we warn as well.\n  const timerIndex = timerIDs.indexOf(timerID);\n  if (timerIndex === -1) {\n    return;\n  }\n\n  const type = types[timerIndex];\n  const callback = callbacks[timerIndex];\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n\n  if (__DEV__) {\n    Systrace.beginEvent(type + ' [invoke]');\n  }\n\n  // Clear the metadata\n  if (type !== 'setInterval') {\n    _clearIndex(timerIndex);\n  }\n\n  try {\n    if (\n      type === 'setTimeout' ||\n      type === 'setInterval' ||\n      type === 'setImmediate'\n    ) {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(performanceNow());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function() {\n          // TODO: Optimisation: allow running for longer than one frame if\n          // there are no pending JS calls on the bridge from native. This\n          // would require a way to check the bridge queue synchronously.\n          return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));\n        },\n        didTimeout: !!didTimeout,\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    // Don't rethrow so that we can run all timers.\n    if (!errors) {\n      errors = [e];\n    } else {\n      errors.push(e);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\n\n/**\n * Performs a single pass over the enqueued immediates. Returns whether\n * more immediates are queued up (can be used as a condition a while loop).\n */\nfunction _callImmediatesPass() {\n  if (immediates.length === 0) {\n    return false;\n  }\n\n  if (__DEV__) {\n    Systrace.beginEvent('callImmediatesPass()');\n  }\n\n  // The main reason to extract a single pass is so that we can track\n  // in the system trace\n  const passImmediates = immediates;\n  immediates = [];\n\n  // Use for loop rather than forEach as per @vjeux's advice\n  // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\n  for (let i = 0; i < passImmediates.length; ++i) {\n    _callTimer(passImmediates[i], 0);\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n  return immediates.length > 0;\n}\n\nfunction _clearIndex(i: number) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n}\n\nfunction _freeCallback(timerID: number) {\n  // timerIDs contains nulls after timers have been removed;\n  // ignore nulls upfront so indexOf doesn't find them\n  if (timerID == null) {\n    return;\n  }\n\n  const index = timerIDs.indexOf(timerID);\n  // See corresponding comment in `callTimers` for reasoning behind this\n  if (index !== -1) {\n    const type = types[index];\n    _clearIndex(index);\n    if (type !== 'setImmediate' && type !== 'requestIdleCallback') {\n      deleteTimer(timerID);\n    }\n  }\n}\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\nconst JSTimers = {\n  /**\n   * @param {function} func Callback to be invoked after `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setTimeout: function(func: Function, duration: number, ...args: any): number {\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(\n        ANDROID_LONG_TIMER_MESSAGE +\n          '\\n' +\n          '(Saw setTimeout with duration ' +\n          duration +\n          'ms)',\n      );\n    }\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setTimeout',\n    );\n    createTimer(id, duration || 0, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setInterval: function(\n    func: Function,\n    duration: number,\n    ...args: any\n  ): number {\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(\n        ANDROID_LONG_TIMER_MESSAGE +\n          '\\n' +\n          '(Saw setInterval with duration ' +\n          duration +\n          'ms)',\n      );\n    }\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setInterval',\n    );\n    createTimer(id, duration || 0, Date.now(), /* recurring */ true);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked before the end of the\n   * current JavaScript execution loop.\n   */\n  setImmediate: function(func: Function, ...args: any) {\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setImmediate',\n    );\n    immediates.push(id);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame.\n   */\n  requestAnimationFrame: function(func: Function) {\n    const id = _allocateCallback(func, 'requestAnimationFrame');\n    createTimer(id, 1, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame and provided\n   * with time remaining in frame.\n   * @param {?object} options\n   */\n  requestIdleCallback: function(func: Function, options: ?Object) {\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(true);\n    }\n\n    const timeout = options && options.timeout;\n    const id = _allocateCallback(\n      timeout != null\n        ? deadline => {\n            const timeoutId = requestIdleCallbackTimeouts[id];\n            if (timeoutId) {\n              JSTimers.clearTimeout(timeoutId);\n              delete requestIdleCallbackTimeouts[id];\n            }\n            return func(deadline);\n          }\n        : func,\n      'requestIdleCallback',\n    );\n    requestIdleCallbacks.push(id);\n\n    if (timeout != null) {\n      const timeoutId = JSTimers.setTimeout(() => {\n        const index = requestIdleCallbacks.indexOf(id);\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n          _callTimer(id, performanceNow(), true);\n        }\n        delete requestIdleCallbackTimeouts[id];\n        if (requestIdleCallbacks.length === 0) {\n          setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n    return id;\n  },\n\n  cancelIdleCallback: function(timerID: number) {\n    _freeCallback(timerID);\n    const index = requestIdleCallbacks.indexOf(timerID);\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n\n    const timeoutId = requestIdleCallbackTimeouts[timerID];\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n  },\n\n  clearTimeout: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearInterval: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearImmediate: function(timerID: number) {\n    _freeCallback(timerID);\n    const index = immediates.indexOf(timerID);\n    if (index !== -1) {\n      immediates.splice(index, 1);\n    }\n  },\n\n  cancelAnimationFrame: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  /**\n   * This is called from the native side. We are passed an array of timerIDs,\n   * and\n   */\n  callTimers: function(timersToCall: Array<number>) {\n    invariant(\n      timersToCall.length !== 0,\n      'Cannot call `callTimers` with an empty list of IDs.',\n    );\n\n    errors = (null: ?Array<Error>);\n    for (let i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n\n    if (errors) {\n      const errorCount = errors.length;\n      if (errorCount > 1) {\n        // Throw all the other errors in a setTimeout, which will throw each\n        // error one at a time\n        for (let ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(\n            (error => {\n              throw error;\n            }).bind(null, errors[ii]),\n            0,\n          );\n        }\n      }\n      throw errors[0];\n    }\n  },\n\n  callIdleCallbacks: function(frameTime: number) {\n    if (\n      FRAME_DURATION - (performanceNow() - frameTime) <\n      IDLE_CALLBACK_FRAME_DEADLINE\n    ) {\n      return;\n    }\n\n    errors = (null: ?Array<Error>);\n    if (requestIdleCallbacks.length > 0) {\n      const passIdleCallbacks = requestIdleCallbacks;\n      requestIdleCallbacks = [];\n\n      for (let i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n\n    if (errors) {\n      errors.forEach(error =>\n        JSTimers.setTimeout(() => {\n          throw error;\n        }, 0),\n      );\n    }\n  },\n\n  /**\n   * This is called after we execute any command we receive from native but\n   * before we hand control back to native.\n   */\n  callImmediates() {\n    errors = (null: ?Array<Error>);\n    while (_callImmediatesPass()) {}\n    if (errors) {\n      errors.forEach(error =>\n        JSTimers.setTimeout(() => {\n          throw error;\n        }, 0),\n      );\n    }\n  },\n\n  /**\n   * Called from native (in development) when environment times are out-of-sync.\n   */\n  emitTimeDriftWarning(warningMessage: string) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  },\n};\n\nfunction createTimer(\n  callbackID: number,\n  duration: number,\n  jsSchedulingTime: number,\n  repeats: boolean,\n): void {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.createTimer(callbackID, duration, jsSchedulingTime, repeats);\n}\n\nfunction deleteTimer(timerID: number): void {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.deleteTimer(timerID);\n}\n\nfunction setSendIdleEvents(sendIdleEvents: boolean): void {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.setSendIdleEvents(sendIdleEvents);\n}\n\nlet ExportedJSTimers: {|\n  callIdleCallbacks: (frameTime: number) => any | void,\n  callImmediates: () => void,\n  callTimers: (timersToCall: Array<number>) => any | void,\n  cancelAnimationFrame: (timerID: number) => void,\n  cancelIdleCallback: (timerID: number) => void,\n  clearImmediate: (timerID: number) => void,\n  clearInterval: (timerID: number) => void,\n  clearTimeout: (timerID: number) => void,\n  emitTimeDriftWarning: (warningMessage: string) => any | void,\n  requestAnimationFrame: (func: any) => any | number,\n  requestIdleCallback: (func: any, options: ?any) => any | number,\n  setImmediate: (func: any, ...args: any) => number,\n  setInterval: (func: any, duration: number, ...args: any) => number,\n  setTimeout: (func: any, duration: number, ...args: any) => number,\n|};\n\nif (!NativeTiming) {\n  console.warn(\"Timing native module is not available, can't set timers.\");\n  // $FlowFixMe: we can assume timers are generally available\n  ExportedJSTimers = ({\n    callImmediates: JSTimers.callImmediates,\n    setImmediate: JSTimers.setImmediate,\n  }: typeof JSTimers);\n} else {\n  ExportedJSTimers = JSTimers;\n}\n\nBatchedBridge.setImmediatesCallback(JSTimers.callImmediates);\n\nmodule.exports = ExportedJSTimers;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}